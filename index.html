<body>

    <div>
        <label for="cutoff">Cutoff</label>
        <input type="range" id="cutoff" min="0" max="100" value="70" />
    </div>
    <div>
        <label for="slope">Slope</label>
        <input type="range" id="slope" min="0.01" max="1" step="0.001" value="0.7" />
    </div>
    
    <!-- A grid with rows (centered, offset, difference) and columns (distance, threshold, logistic) -->
    <!-- make canvas here instead of programmatically? make divs programmatically? -->
    <div id="centerRow"> </div>
    <div id="deltaRow"> </div>
        
    <!-- Final conclusion: add a slider that progressively adds more and more office buildings into a total accessibility indicator (sums and normalizes), which still has the sigmoid and hard cutoff options. -->
    
    <script>


(function() {
'use strict';

// On canvases: https://www.mapbox.com/bites/00009/
// Use specific-width arrays

var width = 400;
var height = 286;
var N = width * height;

function makeCanvas (id, parent) {
  var canvas = document.createElement('canvas');
  canvas.id = id;
  canvas.width = width;
  canvas.height = height;
  document.getElementById(parent).appendChild(canvas);
  return canvas;
}

function makeEmptyImageData () {
    var ret = new Array(N);
    for (var i = 0; i < N; i++) {
      ret[i] = 0;
    }
    return ret;
}

function distance (x0, y0, x1, y1) {
    var dx = x1 - x0;
    var dy = y1 - y0;
    return Math.sqrt(dx * dx + dy * dy);
}

function makeDistanceData (cX, cY) {
    var dat = makeEmptyImageData();
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            dat[y * width + x] = distance(cX, cY, x, y)
        }
    }
    return dat;
}

function applyDataToCanvas (canvas, dataIn, scale, signed) {
    var ctx = canvas.getContext("2d");
    var imgData = ctx.createImageData(width, height);  
    var data = imgData.data;
    if (scale == 0) {
        // Auto-normalize
        var absMax = Math.max(Math.max(...dataIn), -Math.min(...dataIn));
        scale = 255 / absMax;
    }
    // Iterate over distance values
    var j = 0;
    for (var i = 0; i < N; i++) {
        var val = dataIn[i] * scale;
        if (signed) {
            // Blue-red color scheme for positive and negative
            if (val >= 0) {
                data[j++] = 0;
                data[j++] = 0;
                data[j++] = val;
                data[j++] = 255;
            } else {
                data[j++] = -val;
                data[j++] = 0;
                data[j++] = 0;
                data[j++] = 255;
            }
        } else {
            // set RGB all to the same value
            data[j++] = val;
            data[j++] = val;
            data[j++] = val;
            data[j++] = 255;
        }
    }
    ctx.putImageData(imgData, 0, 0);
}

function threshold (array, cutoff) {
    var result = new Array(N);
    for (var i = 0; i < N; i++) {
        result[i] = (array[i] < cutoff) ? 1 : 0;
    }
    return result;
}

function logistic (array, cutoff, slope) {
    var result = new Array(N);
    for (var i = 0; i < N; i++) {
        result[i] = 1 / (1 + Math.exp(slope * (array[i] - cutoff)));
    }
    return result;
}

function elementWiseDelta (array0, array1) {
    var delta = new Array(N);
    for (var i = 0; i < N; i++) {
        delta[i] = array1[i] - array0[i];
    }
    return delta;
}


// Grab sliders and other input widgets and set their widths

var cutoff = document.getElementById("cutoff");
cutoff.style.width = "100%";
var slope = document.getElementById("slope");
slope.style.width = "100%";

// Create a grid of canvases

var centerDistanceCanvas  = makeCanvas('centerDistanceCanvas',  'centerRow');
var centerThresholdCanvas = makeCanvas('centerThresholdCanvas', 'centerRow');
var centerLogisticCanvas  = makeCanvas('centerLogisticCanvas',  'centerRow');

var deltaDistanceCanvas  = makeCanvas('deltaDistanceCanvas',  'deltaRow');
var deltaThresholdCanvas = makeCanvas('deltaThresholdCanvas', 'deltaRow'); 
var deltaLogisticCanvas  = makeCanvas('deltaLogisticCanvas',  'deltaRow');

// Arrays of length N holding single-band image data, will be initialized on redraw

// Centered departure point
var centerDistanceData;
var centerThresholdData;
var centerLogisticData;

// Off-center departure point
var offsetDistanceData;
var offsetThresholdData;
var offsetLogisticData;

// The difference of the offset and centered results
var deltaDistanceData;
var deltaThresholdData;
var deltaLogisticData;

function updateAll() {
    deltaDistanceData  = elementWiseDelta(centerDistanceData,  offsetDistanceData);
    applyDataToCanvas(centerDistanceCanvas, centerDistanceData, 1.5);
    applyDataToCanvas(deltaDistanceCanvas, deltaDistanceData, 50, true); // auto normalize, bidirectional signal    
    updateThreshold(); // cascade redraw of all other canvases 
}

function updateThreshold () {
    centerThresholdData = threshold(centerDistanceData, cutoff.value);
    offsetThresholdData = threshold(offsetDistanceData, cutoff.value);
    deltaThresholdData = elementWiseDelta(centerThresholdData, offsetThresholdData);
    applyDataToCanvas(centerThresholdCanvas, centerThresholdData, 255);
    applyDataToCanvas(deltaThresholdCanvas, deltaThresholdData, 255, true);
    updateLogistic(); // cascade redraw of sigmoid smoothed data
};

function updateLogistic () {
    centerLogisticData = logistic(centerDistanceData, cutoff.value, slope.value); 
    offsetLogisticData = logistic(offsetDistanceData, cutoff.value, slope.value); 
    deltaLogisticData = elementWiseDelta(centerLogisticData,  offsetLogisticData); 
    applyDataToCanvas(centerLogisticCanvas,  centerLogisticData , 255);
    applyDataToCanvas(deltaLogisticCanvas,   deltaLogisticData ,  350, true);
};

// Load travel time data A from an image file.
var imga = new Image();
imga.onload = function() { 
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext("2d");
    context.drawImage(imga,0,0);
    var dat = makeEmptyImageData();
    var rgbaData = context.getImageData(0, 0, width, height);
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var pos = y * width + x;
            dat[pos] = rgbaData.data[4 * pos];
        }
    }
    centerDistanceData = dat;
    updateAll(); // trigger full redraw when image data is processed
};
imga.src = "pdx_raster_a.png";

// Load travel time data B from an image file.
var imgb = new Image();
imgb.onload = function() { 
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext("2d");
    context.drawImage(imgb,0,0);
    var dat = makeEmptyImageData();
    var rgbaData = context.getImageData(0, 0, width, height);
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var pos = y * width + x;
            dat[pos] = rgbaData.data[4 * pos];
        }
    }
    offsetDistanceData = dat;
    updateAll(); // trigger full redraw when image data is processed
};
imgb.src = "pdx_raster_b.png";

// The change event is triggered on mouse release; the input event is triggered on mouse move.
// TODO centered images do not always need to be updated. Cutoff and slope for the two rows could be decoupled.
cutoff.oninput = updateThreshold;
slope.oninput = updateLogistic;

updateAll(); // trigger full redraw

// TODO ondrag for the three offset canvases

}()); // close namespace and call to execute.

</script>
</body>